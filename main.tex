\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{xcolor}
\usepackage[a4paper]{geometry}

\title{BUSA8090 - Assignment 1, Task 1}
\author{Samuel Gardiner (44952619)}
\date{17 March 2020}

% Setup:
\setcounter{secnumdepth}{0}

\definecolor{mannibg}{HTML}{f0f3f3}

\newminted[bashcode]{bash}{
    style = friendly,
    bgcolor=mannibg
}

\newminted[bashinline]{text}{
    style = friendly,
    bgcolor=mannibg,
    breaklines,
    mathescape
}

\newmintedfile[bashfile]{bash}{
    style=manni,
    bgcolor=mannibg,
    linenos
}

% Content

\begin{document}

\maketitle

\section{Question 1}

We present a script \texttt{newer.sh} which, when given a list of filenames as its command-line arguments, prints the name of the newest file. Executable source code is available at \url{https://raw.githubusercontent.com/gardiners/a1t1/master/newer.sh}

\bashfile{newer.sh}

The \texttt{if} conditional at lines 7-10 checks whether the user has given any arguments. If the list of arguments (that is, \texttt{\$*}) is empty, our script prints a helpful usage message, and then quits.

The heavy lifting is performed by the command \texttt{ls -t \$*} on line 13. The \texttt{-t} argument tells \texttt{ls} to sort its output by file time, and we have provided our list of script-calling arguments \texttt{\$*} as the input. The output of \texttt{ls} is captured by the \texttt{\$()} construct, and then captured again by an outer pair of parentheses to form a \texttt{bash} array which we have named \texttt{sorted}.

To print the name of the newest file, we simply return the first element (ie element \texttt{[0]}) of our array at line 15. 

To test whether the script works, we create three files with known modification times and check whether \texttt{newer.sh} correctly returns the newest:

\begin{bashinline}
ubuntu@ip-172-31-20-200:~/busa/a1t1$ touch -t 202003151800 foo
ubuntu@ip-172-31-20-200:~/busa/a1t1$ touch -t 202003151801 goo
ubuntu@ip-172-31-20-200:~/busa/a1t1$ touch -t 202003151802 hoo
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./newer.sh foo goo hoo
hoo
\end{bashinline}

As expected, the script returns the newest file, \texttt{hoo}, which has a modification time a minute later than \texttt{goo} and two minutes later than \texttt{foo}. This remains the case if we change the order of the filename arguments:

\begin{bashinline}
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./newer.sh goo hoo foo
hoo
\end{bashinline}

If we specify a filename that doesn't exist, we get a useful error message from \texttt{ls} itself on \texttt{stderr}, but still get the newest of the files that we correctly specified:

\begin{bashinline}
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./newer.sh foo bar hoo goo baz
ls: cannot access 'bar': No such file or directory
ls: cannot access 'baz': No such file or directory
hoo
\end{bashinline}

Finally, if we specify no filenames at all, we get a helpful message explaining how to use the script:

\begin{bashinline}
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./newer.sh
Usage: ./newer.sh [FILE]...
\end{bashinline}

\section{Question 2}

We present our script \texttt{test\_me.sh}, which prints the text ``This is a TEST'' to the terminal if called without any arguments, but prints ``This is NOT a test'' if called with any arguments. Source code is available at \url{https://raw.githubusercontent.com/gardiners/a1t1/master/test_me.sh}

\bashfile{test_me.sh}

The conditional \texttt{if} at line 7 checks the number of arguments. Since the integer 0 is interpreted as Boolean TRUE in \texttt{bash}, if we have no arguments, the `\texttt{then}' branch of the conditional executes. The complement of \texttt{\$# = 0} is the case where we have any arguments, and in this circumstance the `\texttt{else}' branch is executed.

We can test our script under either of these conditions:

\begin{bashinline}
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./test_me.sh
This is NOT a test
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./test_me.sh foo
This is a TEST
ubuntu@ip-172-31-20-200:~/busa/a1t1$ ./test_me.sh foo bar baz
This is a TEST
\end{bashinline}

We can see that our script has returned the desired output in the zero-argument case, the one-argument case, and the many-argument case.

\section{Question 3}

\subsection{a)}

\textbf{Program 24} is the shell script \texttt{time-signal.sh}, printed at Wünschiers 10.11.2. The script is provided online by Wünschiers with the URL
\url{https://www.staff.hs-mittweida.de/~wuenschi/data/media/compbiolbook/chapter-10-shell-programming--time-signal.sh}. Since this is a publicly available URL, we can easily use \texttt{curl} to read the script from Wünschiers' webserver and write it to a directory on our Ubuntu instance. \texttt{>}.

First, we create the directory \url{~/bin}:
\begin{bashinline}
ubuntu@ip-172-31-20-200:~$ mkdir -p ~/bin
ubuntu@ip-172-31-20-200:~$ ls -lah ~/bin
total 8.0K
drwxrwxr-x  2 ubuntu ubuntu 4.0K Mar 17 10:23 .
drwxr-xr-x 12 ubuntu ubuntu 4.0K Mar 17 09:04 ..
\end{bashinline}

We have used the \texttt{-p} argument to \texttt{mkdir} as it prevents \texttt{mkdir} from generating an error if the directory already exists (for example, in the case that this command is run by a peer marker).

Now, we can write the file \url{~/bin/time-signal.sh} using \texttt{curl}, and set it to be executable with \texttt{chmod}:

\begin{bashinline}
ubuntu@ip-172-31-20-200:~$ curl -o ~/bin/time-signal.sh https://www.staff.hs-mittweida.de/~wuenschi/data/media/compbiolbook/
    chapter-10-shell-programming--time-signal.sh
 % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                Dload  Upload   Total   Spent    Left  Speed
100   224  100   224    0     0    127      0  0:00:01  0:00:01 --:--:--   127
ubuntu@ip-172-31-20-200:~$ chmod u+x ~/bin/time-signal.sh
ubuntu@ip-172-31-20-200:~$ ls -lah ~/bin/time-signal.sh
-rwxrw-r-- 1 ubuntu ubuntu 224 Mar 17 10:42 /home/ubuntu/bin/time-signal.sh
\end{bashinline}

We elected to use the \texttt{-o} (output file) switch for \texttt{curl} to specify the destination, although we also could have used the file redirect operator \texttt{>}. 

\subsection{b)}

From \texttt{man bash}:

\begin{bashinline}
((expression))
      The expression is evaluated according to the rules described below under ARITHMETIC EVALUATION.  If the value of the expression is non-zero, the return status is 0; otherwise the return  status is 1.  This is exactly equivalent to let "expression".
...
ARITHMETIC EVALUATION
       The shell allows arithmetic expressions to be evaluated,  under
       certain  circumstances  (see  the  let and declare builtin com‐
       mands, the ((  compound  command,  and  Arithmetic  Expansion).
...
       = *= /= %= += -= <<= >>= &= ^= |=
              assignment
...
        Within an expression, shell variables may also be referenced by name
        without using  the parameter  expansion  syntax.
\end{bashinline}

Which we compare to the current form of line 9 of \texttt{time-signal.sh}:

\begin{bashcode}
count=$[$count+1]
\end{bashcode}

So, the syntax ``\texttt{let count=count+1}'' evaluates \texttt{count+1} and reassigns it to \texttt{count}, which is the same outcome as performing the evaluation using arithmetic expansion. When using \texttt{let}, the \texttt{\$} can be omitted from the variable names.

\subsection{c)}

The \texttt{expr} command evaluates arithmetic expressions given as its arguments. The \texttt{\$()} construct captures its output and it is assigned to the variable \texttt{count}. Examining the entire command

\begin{bashcode}
count=$(expr $count + 1)
\end{bashcode}

We can therefore construct the sequence of operations that yields the result:
\begin{itemize}
\item \texttt{\$count} is substituted with its value (hopefully an integer)
\item \texttt{expr} evaluates its arguments
\item \texttt{\$()} captures the results of executing \texttt{expr}; and
\item the result is reassigned to \texttt{count}.
\end{itemize}

This is the same outcome as the original code (that is, incrementing the value of \texttt{count}).

\subsection{d)}

From \texttt{man bash}:

\begin{bashinline}
Arithmetic Expansion
    Arithmetic expansion allows the evaluation of an arithmetic expression and the substitution of the result.  The format for arithmetic expansion is:

        $((expression))

    The old format $[expression] is deprecated and will be removed in upcoming versions of bash.
\end{bashinline}

So, the expressions

\begin{bashcode}
$((count+1))
\end{bashcode}

and

\begin{bashcode}
$[$count+1]
\end{bashcode}

are functionally identical, although the latter form should be avoided as it may stop working in a future version of \texttt{bash}. The inner \texttt{\$} symbol could safely be omitted in the original code, in keeping with \texttt{bash}'s rules for arithmetic expansion and arithmetic evaluation.

Both versions of the code increment \texttt{count}.

\end{document}

